{"noir_version":"0.32.0+c679f01a19b02ad2ac2287c8e699b46887f7872c","hash":396539449647247999,"abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"},{"name":"vote","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"path_indices","type":{"kind":"field"},"visibility":"private"},{"name":"siblings","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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+dgj+vOx196fj73e/nzsEf358dfenx9/vf358Uf058dfe39+/PX258cf0Z+Pu/b+fNz19ufjjujPx117fz7uevvzcUf05+OvvT8ff739+fgj+vPx196fj7/e/nz8Ef35hGvvzydcb38+4Yj+fMK19+cTrrc/n3BEf37utffn515vf37uEf35udfen597vf35uUf05xOvvT+feL39+cQj+vOJ196fT7ze/nziEf35pGvvzyddb38+6Yj+fNK19+eTrrc/n3REfz752vvzydfbn08+oj+ffO39+eTr7c8nH9GfX3nt/fmV19ufX3lEf37ltffnV15vf37lEf35tdfen197vf35tUf059dee39+7fX259ce0Z9Pufb+fMr19udTjujPp1x7fz7levvzKUf051OvvT+fer39+dQj+vOp196fT73e/nzqEf35tGvvz6ddb38+7Yj+fNq19+fTrrc/n3ZEf37Ptffn91xvf37PEf35Pdfen99zvf35PUf059OvvT+ffr39+fQj+vPp196fT7/e/nz6Ef35I9fenz9yvf35I0f0549ce3/+yPX2548c0Z8/ee39+ZPX258/eUR//uS19+dPXm9//uQR/fmMa+/PZ1xvfz7jiP58xrX35zOutz+fcUR/PvPa+/OZ19ufzzyiP5957f35zOvtz2deZ3/+5wLZ973y5/NuHnD/i0WLXZOyd908/C4Xhy9Z1Pqfi1OvvOduV75u/fe7XPn5TdvfufKzK7ZfLoK9+n3y11tW26OMkufedafn3m35c5WW/rp1d9mtr6vH4f6b72+1TRYYv/CmP+WXnueq90ub77FDm+W591z/3P/cKHNxpU/uv/mcu25suvf/b/Iym7affZcrX7d+zq0/v2Xz/Ytt3nvr+27tj1vH4da23/vi/5+/t75Xxu3uG5tu/fP/5Xn32bzn7pt23POq37v177f6gDzn+TafddPmvW945Xt13OuyH+92VTvutrH51s+++w6ffRCvNv1ycVV7Lq7qu217nrWuPeo+m/ZsP2uPOXnPi8Mc8V/Zfmsb7rP5vW0bd5jfl228xzW08Z63056F46Pvs2nP9rPutd52Jc+/NR9uY9xr7Nrn+jKm3n3zeffftOPWz7tl8560ea++8r3Emqvn8L0vDufzrc+79fttjXDXq373ns/hd29t163vv/uVz7n7Vb+/jXVX23TL5rl754lbrmrLvTc/v/U9r3/lz+e/uO3r9vLd1X2wfdYb/T8+6+LiMG/cvGnfrW299b03bb7fzrHte7dz9j538Hvb58rr7lf9zjYe3mvTplu/3+bB9fnh2XPhPpv2ybNvvqqt2/G861XvufV3b9m85+2u/PmcxuRqP90+49b3PN/mZ8/Jn259zzv+F5/3fM/h8+56O896l//HZ11cHPrTfTbtu7Wtt773ps2//7/40x393vaz5HWvq35nm7u2bbrPVZ/zvJvfWZY/9LM3SN7rdtq/bd89rmr7827ed/+LfeLSrc++2m/vyLe3Me3W94wrf96ef/xX+ez/A/hhNMkd7QQA","debug_symbols":"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","file_map":{"22":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"23":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"26":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constraint the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\nfn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::from_slice(domain_generators.as_slice());\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = crate::field::bn254::decompose_hint(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"28":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\nuse crate::hash::poseidon::PoseidonConfig;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(\n        consts::x5_2_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(\n        consts::x5_3_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(\n        consts::x5_4_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(\n        consts::x5_5_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(\n        consts::x5_6_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(\n        consts::x5_7_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(\n        consts::x5_8_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(\n        consts::x5_9_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(\n        consts::x5_10_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(\n        consts::x5_11_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(\n        consts::x5_12_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(\n        consts::x5_13_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(\n        consts::x5_14_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(\n        consts::x5_15_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(\n        consts::x5_16_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(\n        consts::x5_17_config(),\n        state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"29":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\nmod perm;\nmod consts;\n\nuse crate::hash::poseidon::{PoseidonConfig, absorb};\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"30":{"source":"mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::field::modulus_num_bits;\nuse crate::hash::Hasher;\nuse crate::default::Default;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\nstruct PoseidonConfig<let T: u32, let N: u32, let X: u32> { \n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n     // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X]\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T]\n) -> [Field; T] {\n    let PoseidonConfig {t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } = pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf/2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf/2+1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O] // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i+1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\n// Check security of sponge instantiation\nfn check_security(rate: Field, width: Field, security: Field) -> bool {\n    let n = modulus_num_bits();\n\n    ((n - 1) as Field * (width - rate) / 2) as u8 > security as u8\n}\n\nstruct PoseidonHasher{\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        } \n        if len == 2 {\n            result = bn254::hash_2([self._state[0],self._state[1]]);\n        } \n        if len == 3 {\n            result = bn254::hash_3([self._state[0],self._state[1],self._state[2]]);\n        } \n        if len == 4 {\n            result = bn254::hash_4([self._state[0],self._state[1],self._state[2],self._state[3]]);\n        } \n        if len == 5 {\n            result = bn254::hash_5([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4]]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5]]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6]]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7]]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8]]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9]]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10]]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11]]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11], self._state[12]]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11], self._state[12], self._state[13]]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11], self._state[12], self._state[13], self._state[14]]);\n        }\n        \n        result\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher{\n    fn default() -> Self{\n        PoseidonHasher{\n            _state: &[],\n        }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a, 0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29, 0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c\n            ];\n            assert_eq(expected, poseidon::bn254::perm::x5_3(state), \"Failed to reproduce output for [0, 1, 2]\");\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465, 0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d, 0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907, 0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e, 0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7\n            ];\n            assert_eq(\n                expected, poseidon::bn254::perm::x5_5(state), \"Failed to reproduce output for [0, 1, 2, 3, 4]\"\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"33":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"53":{"source":"use std::hash::poseidon::bn254::hash_1;\nuse std::hash::poseidon::bn254::hash_2;\n////// Checkpoint 4 //////\n// use binary_merkle_root::binary_merkle_root;\n\nfn main(\n    // public inputs\n    root: pub Field,\n    nullifier_hash: pub Field,\n    vote: pub Field, // 0 or 1\n    // private inputs\n    nullifier: Field,\n    secret: Field,\n    path_indices: Field, // index\n    siblings: [Field; 16],\n) {\n    // 1. Calculate commitment\n    // commitment = hash(secret, nullifier)\n    let commitment = hash_2([secret, nullifier]);\n\n    // 2. Calculate nullifier hash\n    // nullifier_hash = hash(nullifier, secret)\n    // Using swapped order to distinguish from commitment. \n    // Ideally we'd use a different hash or domain separator, but this works for simple unique constraints.\n    let calculated_nullifier_hash = hash_2([nullifier, secret]);\n    assert(calculated_nullifier_hash == nullifier_hash);\n\n    // 3. Verify Merkle Proof\n    // Use std::merkle::compute_merkle_root\n    let calculated_root = std::merkle::compute_merkle_root(commitment, path_indices, siblings);\n    assert(calculated_root == root);\n\n    // 4. Constrain vote to be 0 or 1\n    assert(vote * (vote - 1) == 0);\n}\n","path":"/home/guy_do_or_die/workspace/buidlguidl/speedrun/challenge-zk-voting/packages/circuits/src/main.nr"}},"names":["main"]}